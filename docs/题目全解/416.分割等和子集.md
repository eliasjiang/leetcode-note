

回溯法 超时
```typescript
function partiton(nums: number[], index: number, sum: number, target: number) {
  if(sum + nums[index] > target) return false;
  else if(sum + nums[index] == target) return true;
  else {
    sum += nums[index];
    for(let i = index+1; i < nums.length; i++){
        if(i!=index+1 && nums[i] == nums[i-1]) continue;
        if(partiton(nums, i, sum, target)) return true;
    }
    return false;
  }
}
function canPartition(nums: number[]): boolean {
  return partiton(nums, 0, 0, nums.reduce((a, b) => a + b, 0) / 2);
}
```

转化为01背包问题
```typescript
function canPartition(nums: number[]): boolean {
    let sum:number = nums.reduce((a,b)=>a+b,0);
    if(sum%2!==0) return false;
    let target:number = sum/2;
    let dp:number[][] = [];

    for(let i=0;i<nums.length+1;i++){
        dp.push(new Array(target+1).fill(0));
    }
    
    for(let j=nums[0];j<target+1;j++){
        dp[0][j] = nums[0]
    }


    for(let i=1;i<nums.length+1;i++){
        for(let j=1;j<target+1;j++){
            if(j>=nums[i]){
                dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-nums[i]]+nums[i]);
            }else{
                dp[i][j] = dp[i-1][j];
            }
        }
    }

    
    return dp[nums.length][target]===target;

}
```