
深度搜索算法
```typescript
let dir:number[][] = [[-1,0],[0,-1],[1,0],[0,1]];
let count:number;

function numEnclaves(grid: number[][]): number {
    count = 0;
    let n  = grid.length
    let m = grid[0].length

    for(let i=0;i<n;i++){
        if(grid[i][0] == 1) dfs(grid,i,0);
        if(grid[i][m-1]==1) dfs(grid,i,m-1)
    }

    for(let j=0;j<m;j++){
        if(grid[0][j]==1) dfs(grid,0,j);
        if(grid[n-1][j]==1) dfs(grid,n-1,j);
    }
    count = 0;

    for(let i=0;i<n;i++){
        for(let j=0;j<m;j++){
            if(grid[i][j] == 1) dfs(grid,i,j);
        }
    }

    return count;
};

function dfs(grid: number[][],x:number,y:number){
    grid[x][y] = 0;
    count++;
    for(let i = 0;i<4;i++){
        let nextX = x + dir[i][0]
        let nextY = y + dir[i][1]
        if(nextX<0||nextX>=grid.length||nextY<0||nextY>=grid[0].length) {continue;}
        if(grid[nextX][nextY] == 0) {continue;}
        dfs(grid,nextX,nextY);
    }
    return;
};
```

广度搜索法
```typescript
let dir: number[][] = [
    [-1, 0],
    [0, -1],
    [1, 0],
    [0, 1],
];
let count: number;

function numEnclaves(grid: number[][]): number {
    count = 0;
    let n = grid.length;
    let m = grid[0].length;

    for (let i = 0; i < n; i++) {
        if (grid[i][0] == 1) bfs(grid, i, 0);
        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);
    }

    for (let j = 0; j < m; j++) {
        if (grid[0][j] == 1) bfs(grid, 0, j);
        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);
    }

    count = 0;

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (grid[i][j] == 1) bfs(grid, i, j);
        }
    }

    return count;
}

function bfs(grid: number[][], x: number, y: number) {
    let queue: number[][] = [];
    queue.push([x, y]);
    grid[x][y] = 0;
    count++;
    while (queue.length != 0) {
        let [px, py] = queue.shift();

        for (let i = 0; i < 4; i++) {
            let nextX = px + dir[i][0];
            let nextY = py + dir[i][1];
            if (
                nextX < 0 ||
                nextX >= grid.length ||
                nextY < 0 ||
                nextY >= grid[0].length
            ) {
                continue;
            }
            if (grid[nextX][nextY] == 0) {
                continue;
            }
            queue.push([nextX, nextY]);
            count++;
            grid[nextX][nextY] = 0;
        }
    }
}
```